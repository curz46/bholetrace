#version 430

layout (local_size_x = 1, local_size_y = 1) in;

layout (rgba32f, binding = 0) uniform image2D destTex;
uniform samplerCube skybox;

layout (location = 0) uniform vec2 size;

struct Camera {
    vec3 pos;
    vec3 rot;
    float fov;
};

layout (location = 1) uniform Camera camera;

float solve_quadratic(float a, float b, float c) {
    float x0, x1;
    float d = b * b - 4 * a * c;
    if (d < 0)
        return -1.;
    else if (d == 0)
        x0 = x1 = -0.5 * b / a;
    else {
        float q = b > 0
            ? -0.5 * (b + sqrt(d))
            : -0.5 * (b - sqrt(d));
        x0 = q / a;
        x1 = c / q;
    }
    if (x0 < x1)
        return x0;
    else
        return x1;
}

bool intersect_sphere(vec3 spos, float radius, vec3 origin, vec3 dir) {
    vec3 L = origin - spos;
    float a = dot(dir, dir);
    float b = 2 * dot(dir, L);
    float c = dot(L, L) - radius*radius;
    float t0 = solve_quadratic(a, b, c);
    return t0 > 0;
}

vec3 rx(vec3 v, float angle) {
    vec3 ret;

    if (angle != 0) {
        angle = radians(angle);
        ret.x = v.x;
        ret.y = v.y * cos(angle) - v.z * sin(angle);
        ret.z = v.y * sin(angle) + v.z * cos(angle);
        return ret;
    }
    return v;
}

vec3 ry(vec3 v, float angle) {
    vec3 ret;

    if (angle != 0) {
        angle = radians(angle);
        ret.x = v.x * cos(angle) + v.z * sin(angle);
        ret.y = v.y;
        ret.z = v.z * cos(angle) - v.x * sin(angle);
        return ret;
    }
    return v;
}

vec3 rz(vec3 v, float angle) {
    vec3 ret;

    if (angle != 0) {
        angle = radians(angle);
        ret.x = v.x * cos(angle) - v.y * sin(angle);
        ret.y = v.x * sin(angle) + v.y * cos(angle);
        ret.z = v.z;
        return ret;
    }
    return v;
}

vec3 rotate(vec3 v, vec3 r) {
    v = rx(v, r.x);
    v = ry(v, r.y);
    v = rz(v, r.z);
    return v;
}

vec3 ppos_dir(vec2 pos) {
    return normalize(vec3(
        (size.x/2) - pos.x,
        (size.y/2) - pos.y,
        (size.x/2) / tan(radians(camera.fov/2))
    ));
}

void main() {
    vec2 ppos = gl_GlobalInvocationID.xy;
    vec3 direction = normalize(rotate(ppos_dir(ppos), camera.rot));

    vec3 spos = vec3(100., 0., 100.);
    float radius = 30;
    vec4 color;
    if (intersect_sphere(spos, radius, camera.pos, direction))
        color = vec4(0.75, 0., 0., 1.);
    else
        color = texture(skybox, direction);
    imageStore(destTex, ivec2(ppos), color);
}
